Cant-Be-Late Scheduling Problem
================================

Problem Setting
--------

You are given a long-running compute job that must complete before a fixed **hard deadline**.  
At each time step, you must choose which type of cloud compute resource to use:

- **Spot instances**  
  - Very cheap  
  - May become unavailable at certain timesteps  
  - Can be preempted at any time, the job will incur a **restart overhead**

- **On-demand instances**
  - Guaranteed available  
  - Expensive  
  - Never interrupted
  
Your strategy must decide at every timestep whether to use Spot, use On-Demand, or pause (NONE).  

Restart overheads do not stack: launching a new instance while an old overhead is still pending will replace the previous remaining restart overhead with the new one.

Your goal is to **finish before the deadline** while **minimizing cost**.


The evaluation uses many real spot-availability traces.
---

API Specification
-----------------

Implement a `Solution` class:

```python
class Solution:
    def solve(self, spec_path: str = None) -> str | dict:
        """
        Returns a scheduling strategy implementation.
        
        Returns one of:
        - Python code string implementing a Strategy subclass
        - {"code": "python_code_string"}
        - {"program_path": "path/to/strategy.py"}
        """
        # Your implementation
        pass
```

Your strategy code must implement:

```python
from sky_spot.strategies.strategy import Strategy
from sky_spot.utils import ClusterType

class YourStrategy(Strategy):
    NAME = "your_strategy_name"  # REQUIRED: Add unique identifier
    
    def _step(self, last_cluster_type: ClusterType, has_spot: bool) -> ClusterType:
        """
        Return next cluster type to use.
        
        Available attributes:
        - self.env.elapsed_seconds: Current time elapsed
        - self.env.gap_seconds: Time step size
        - self.env.cluster_type: Current cluster type
        - self.task_duration: Total task duration needed
        - self.task_done_time: List of completed work segments
        - self.deadline: Deadline time
        - self.restart_overhead: Time overhead when restarting
        
        Returns: ClusterType.SPOT, ClusterType.ON_DEMAND, or ClusterType.NONE
        """
        # Implement your decision logic
        pass
    
    @classmethod
    def _from_args(cls, parser):  # REQUIRED: For evaluator instantiation
        args, _ = parser.parse_known_args()
        return cls(args)
```

Parameters:
---------------
### ClusterType:
ClusterType has 3 members: 

ClusterType.SPOT: Spot type cluster.

ClusterType.ON_DEMAND: On Demand type cluster.

ClusterType.None: None, no cluster.

#### You are given some fixed parameters:

env.gap_seconds: The size of each time step, in seconds.

task_duration: The total amount of work time required to finish the task (in seconds).

deadline: The task’s deadline (in seconds).

restart_overhead: The time overhead incurred when a job restarts.

You should implement the function to return the next cluster type to use as described above.

####  At each time step, you are given:

env.elapsed_seconds: Current time elapsed (in second).

env.cluster_type: The current cluster type running your task.

task_done_time: A list of completed work segments, where sum(self.task_done_time) = the amount of successful work time accumulated so far.

has_spot: A boolean indicating whether the Spot cluster is available in the current time step. If False, the strategy must not return ClusterType.SPOT (doing so will raise an error).

#### You should return:

ClusterType.SPOT: if you want to run the next time step on the Spot cluster.

ClusterType.ON_DEMAND: if you want to run the next time step on the On-Demand cluster.

ClusterType.NONE: if you choose not to run on any cluster during the next time step; this incurs no cost.

Scoring (0-100)
---------------
```
OD_anchor = Cost of running fully on-demand (baseline upper bound)
SPOT_anchor = Cost of running fully on spot (baseline lower bound)
AvgCost = Your strategy's average cost

normalized_score = (OD_anchor - AvgCost) / (OD_anchor - SPOT_anchor)
score = clip(normalized_score, 0, 1) × 100
```

Notice that if you fail to finish the task before the deadline, you will receive a penalty score of -100000.

Evaluation Details
------------------
- Tested on 720 real Spot instance traces
- Task duration: 48 hours
- Deadline: 52 hours (4-hour slack)
- Restart overhead: 0.20 hours (12 minutes)
- Price of on-demand is 3.06$/hr
- Price of Spot is 0.9701$/hr
- 0 = Cost of full on-demand
- 100 = Cost of optimal spot strategy

- Notice your solution will be tested on real traces with mixed Spot availability (both high 43-78% and low 4-40% availability regions).

Your program has a total time limit of 300 seconds. You may be evaluated for up to 52 × 60 × 60 = 187200 time steps. Please ensure that your code is efficient under python.

Implementation Notes
---------------------
**Required Elements (Missing these will cause evaluation failures):**
- `NAME` attribute must be defined on your Strategy class (avoids "Name abstract already exists" error)
- `_from_args` classmethod must be implemented (avoids JSON decode errors)
- Ensure proper handling of ClusterType.NONE return values (avoids "Timestamp X out of range X" error)
- `__init__(self, args)` must match the Strategy base class (changed from `__init__(self, args=None)`)



Concrete Step Example:
----------------------
Here is a concrete example demonstrating our environment.
Assume we are:
```
Parameter                | Value
-------------------------|------------------------
env.gap_seconds          | 3600.0
env.elapsed_seconds      | 18000
task_done_time           | [3600, 3600, 2880, 3600, 3600]
has_spot                 | True
env.cluster_type         | ClusterType.ON_DEMAND
```
If our strategy returns ClusterType.SPOT, there will be a restart overhead:
```
Parameter                | Value
-------------------------|------------------------
env.gap_seconds          | 3600.0
env.elapsed_seconds      | 23400
task_done_time           | [3600, 3600, 2880, 3600, 3600, 2880]
has_spot                 | True
env.cluster_type         | ClusterType.SPOT
```
If our strategy returns ClusterType.ON_DEMAND:
```
Parameter                | Value
-------------------------|------------------------
env.gap_seconds          | 3600.0
env.elapsed_seconds      | 21600
task_done_time           | [3600, 3600, 2880, 3600, 3600, 3600]
has_spot                 | True
env.cluster_type         | ClusterType.ON_DEMAND
```



